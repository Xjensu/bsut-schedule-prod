<style>
  /* Reset & Basic Styles */
  * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
  }

  body {
      font-family: "SF Pro Text", "Myriad Set Pro", "SF Pro Icons", "Helvetica Neue", "Helvetica", "Arial", sans-serif;
      background-color: transparent; /* Let canvas show through */
      color: #1d1d1f;
      overflow-x: hidden; /* Prevent horizontal scroll */
  }

  #webgl-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1; /* Behind everything */
  }

  /* Navbar Container */
  .uni-header {
      top: 0;
      left: 0;
      width: 100%;
      height: 44px;
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: saturate(180%) blur(20px);
      -webkit-backdrop-filter: saturate(180%) blur(20px);
      z-index: 9999;
      font-size: 12px;
  }

  .header-inner {
      max-width: 1000px;
      margin: 0 auto;
      height: 100%;
      padding: 0 22px;
      display: flex;
      justify-content: space-between;
      align-items: center;
  }

  /* Desktop Nav List */
  .main-menu {
      list-style: none;
      display: flex;
      justify-content: space-between;
      width: 100%;
      align-items: center;
      height: 100%;
  }

  .menu-item {
      height: 100%;
      display: flex;
      align-items: center;
  }

  .menu-link {
      color: #1d1d1f;
      text-decoration: none;
      padding: 0 8px;
      transition: color 0.3s ease;
      display: inline-block;
      line-height: 44px;
      opacity: 0.8;
  }

  .menu-link:hover {
      color: #000;
      opacity: 1;
  }

  /* Icons */
  .global-nav-image-regular {
      display: block;
      height: 44px;
      width: auto;
  }

  .global-nav-image-regular svg {
      height: 44px;
      width: auto;
      fill: currentColor;
  }

  /* Mobile Controls (Hidden by default) */
  .mobile-header-controls {
      display: none;
      width: 100%;
      justify-content: space-between;
      align-items: center;
      height: 100%;
  }

  .mobile-header-actions {
      display: flex;
      align-items: center;
      gap: 20px;
  }

  .menu-toggle-btn {
      background: none;
      border: none;
      cursor: pointer;
      width: 18px;
      height: 44px; /* Full height to be easily clickable */
      position: relative;
      padding: 0;
      z-index: 9999; /* Ensure it's above the menu overlay */
  }

  .line {
      display: block;
      width: 100%;
      height: 1px;
      background-color: #1d1d1f;
      position: absolute;
      left: 0;
      transition: all 0.3s ease;
  }

  .line-top {
      top: 18px; /* Center - gap/2 approx */
  }

  .line-bottom {
      top: 26px; /* Center + gap/2 approx */
  }

  /* Hamburger Animation */
  .menu-toggle-btn.active .line-top {
      top: 22px;
      transform: rotate(45deg);
  }

  .menu-toggle-btn.active .line-bottom {
      top: 22px;
      transform: rotate(-45deg);
  }
  .mobile-nav-overlay {
      position: fixed;
      top: 44px;
      left: 0;
      width: 100%;
      height: 0;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: saturate(180%) blur(20px);
      -webkit-backdrop-filter: saturate(180%) blur(20px);
      overflow: hidden;
      transition: height 0.5s cubic-bezier(0.4, 0.01, 0.165, 0.99);
      z-index: 9998;
  }

  .mobile-nav-overlay.open {
      position: fixed;
      height: 100vh;
  }

  .mobile-menu-list {
      list-style: none;
      padding: 40px 40px 0;
      opacity: 0;
      transform: translateY(-20px);
      transition: opacity 0.3s ease, transform 0.3s ease;
      transition-delay: 0s;
  }

  .mobile-nav-overlay.open .mobile-menu-list {
      position: fixed;
      opacity: 1;
      transform: translateY(0);
      transition-delay: 0.2s;
  }

  .mobile-menu-item {
      border-bottom: 1px solid #d2d2d7;
  }

  .mobile-menu-link {
      display: block;
      color: #1d1d1f;
      text-decoration: none;
      font-size: 17px;
      padding: 14px 0;
      transition: color 0.2s;
  }

  .mobile-menu-link:hover {
      color: #2997ff;
  }

  /* Content Placeholder */
  .main-content-wrapper {
      padding-top: 80px; /* More space for fixed navbar */
      padding-bottom: 40px;
      padding-left: 20px;
      padding-right: 20px;
      min-height: 100vh;
  }

  /* Schedule Styles */
  .schedule-wrapper {
      max-width: 1000px;
      margin: 0 auto;
  }

  .page-header {
      text-align: center;
      margin-bottom: 60px;
  }

  .page-header h1 {
      font-size: 48px;
      font-weight: 700;
      letter-spacing: -0.005em;
      margin-bottom: 10px;
      color: #1d1d1f;
  }

  .page-header .subtitle {
      font-size: 24px;
      color: #86868b;
      font-weight: 400;
  }

  .departments-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 60px;
  }

  .department-card {
      background: #fff;
      border-radius: 18px;
      padding: 30px;
      text-decoration: none;
      color: #1d1d1f;
      box-shadow: 0 4px 6px rgba(0,0,0,0.02), 0 12px 24px rgba(0,0,0,0.04);
      transition: all 0.3s cubic-bezier(0,0,0.5,1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border: 1px solid rgba(0,0,0,0.05);
  }

  .department-card:hover {
      transform: scale(1.02);
      box-shadow: 0 8px 15px rgba(0,0,0,0.05), 0 20px 40px rgba(0,0,0,0.1);
  }

  .department-card h2 {
      font-size: 21px;
      font-weight: 600;
      line-height: 1.2;
      margin-right: 15px;
  }

  .department-card .arrow {
      font-size: 24px;
      color: #0066cc;
      opacity: 0;
      transform: translateX(-10px);
      transition: all 0.3s ease;
  }

  .department-card:hover .arrow {
      opacity: 1;
      transform: translateX(0);
  }

  .page-footer {
      text-align: center;
      color: #86868b;
      font-size: 12px;
      line-height: 1.5;
      border-top: 1px solid #d2d2d7;
      padding-top: 40px;
  }

  .page-footer p {
      margin-bottom: 8px;
  }

  .page-footer .feedback {
      color: #1d1d1f;
      font-weight: 500;
  }

  /* Responsive Breakpoint */
  @media (max-width: 833px) {
      .uni-header {
          height: 48px;
      }

      .mobile-nav-overlay {
          top: 48px;
      }

      .menu-toggle-btn {
          height: 48px;
      }

      .main-menu {
          display: none;
      }

      .mobile-header-controls {
          display: flex;
      }
      
      .header-inner {
          padding: 0 16px;
      }

      .page-header h1 {
          font-size: 36px;
      }
      
      .departments-grid {
          grid-template-columns: 1fr;
      }
  }
</style>

<nav class="uni-header">
  <div class="header-inner">
    <ul class="main-menu">
      <li class="menu-item"><a href="<%= root_path %>"  class="menu-link" data-turbo="false">Главная</a></li>
      <li class="menu-item"><a href="https://www.bsut.by" class="menu-link" data-turbo="false">БелГУТ</a></li>
      <li class="menu-item"><%= link_to "Расписание для преподавателей", teachers_path, class: "menu-link" %></li>
      <% if current_user %>
        <li class="menu-item"><%= link_to "Редактировать расписание", admin_faculties_path, class: "menu-link" %></li>
        <li class="menu-item">
          <%= link_to "Обновить ключи", keys_path, 
                class: "menu-link",
                data: { turbo_method: :post, turbo_confirm: "Вы уверены?" } %>
        </li>
        <li class="menu-item">
          <%= link_to "Выйти", destroy_user_session_path, 
                class: "menu-link",
                data: { turbo_method: :delete, turbo_confirm: "Вы уверены?" } %>
        </li>
      <% else %>
        <li class="menu-item"><%= link_to "Войти", new_user_session_path, class: "menu-link" %></li>
      <% end %>
    </ul>
    
    <!-- Mobile Menu Controls -->
    <div class="mobile-header-controls">
      <div class="mobile-header-actions" style="width: 100%; justify-content: flex-end; display: flex;">
        <button class="menu-toggle-btn">
          <span class="line line-top"></span>
          <span class="line line-bottom"></span>
        </button>
      </div>
    </div>
  </div>
  
  <!-- Mobile Menu Overlay -->
  <div class="mobile-nav-overlay">
    <ul class="mobile-menu-list">
      <li class="mobile-menu-item"><a href="<%= root_path %>" class="mobile-menu-link">Главная</a></li>
      <li class="mobile-menu-item"><a href="https://www.bsut.by" class="mobile-menu-link">БелГУТ</a></li>
      <li class="mobile-menu-item"><%= link_to "Расписание для преподавателей", teachers_path, class: "mobile-menu-link" %></li>
      <% if current_user %>
        <li class="mobile-menu-item"><%= link_to "Редактировать расписание", admin_faculties_path, class: "mobile-menu-link" %></li>
        <li class="mobile-menu-item">
          <%= link_to "Обновить ключи", keys_path, 
                class: "mobile-menu-link",
                data: { turbo_method: :post, turbo_confirm: "Вы уверены?" } %>
        </li>
        <li class="mobile-menu-item">
          <%= link_to "Выйти", destroy_user_session_path, 
                class: "mobile-menu-link",
                data: { turbo_method: :delete, turbo_confirm: "Вы уверены?" } %>
        </li>
      <% else %>
        <li class="mobile-menu-item"><%= link_to "Войти", new_user_session_path, class: "mobile-menu-link" %></li>
      <% end %>
    </ul>
  </div>
</nav>

<script>
  document.addEventListener("turbo:load", () => {
    const menuIcon = document.querySelector('.menu-toggle-btn');
    const mobileMenu = document.querySelector('.mobile-nav-overlay');
    const body = document.body;

    if (menuIcon) {
      // Remove existing listeners to avoid duplicates if turbo:load fires multiple times
      const newMenuIcon = menuIcon.cloneNode(true);
      menuIcon.parentNode.replaceChild(newMenuIcon, menuIcon);
      
      newMenuIcon.addEventListener('click', () => {
        newMenuIcon.classList.toggle('active');
        mobileMenu.classList.toggle('open');
        
        if (mobileMenu.classList.contains('open')) {
          body.style.overflow = 'hidden';
        } else {
          body.style.overflow = '';
        }
      });
    }
  });

  function RoundedRectGeometry(width, height, radius) {
      const shape = new THREE.Shape();
      const x = -width / 2, y = -height / 2;
      shape.moveTo(x, y + radius);
      shape.lineTo(x, y + height - radius);
      shape.quadraticCurveTo(x, y + height, x + radius, y + height);
      shape.lineTo(x + width - radius, y + height);
      shape.quadraticCurveTo(x + width, y, x + width, y + height - radius);
      shape.lineTo(x + width, y + radius);
      shape.quadraticCurveTo(x + width, y, x + width - radius, y);
      shape.lineTo(x + radius, y);
      shape.quadraticCurveTo(x, y, x, y + radius);
      return new THREE.ShapeGeometry(shape);
  }

  const Engine = Matter.Engine,
      World = Matter.World,
      Bodies = Matter.Bodies,
      Body = Matter.Body;

  let camera, scene, renderer;
  let particles = []; 

  let engine, world;
  let walls = [];

  const PARTICLE_COUNT = 200; 
  const PARTICLE_BASE_SIZE = 4;
  const PHYSICS_RADIUS_MULTIPLIER = 0.5; 
  const PHYSICS_RADIUS = PARTICLE_BASE_SIZE * PHYSICS_RADIUS_MULTIPLIER; 

  const PARTICLE_COLOR = 0x42A5F5; 

  const ATTRACTION_RADIUS = 350; 
  const ORBIT_RADIUS = 120; 
  const FORCE_STRENGTH = 0.00005; 

  const PULSE_SPEED = 0.003;
  const PULSE_AMPLITUDE = 0.2; 

  let mouse = new THREE.Vector2(-9999, -9999);
  let mouseLight; // Источник света, следующий за мышью

  function init() {
      const canvas = document.getElementById('webgl-canvas');

      engine = Engine.create();
      world = engine.world;
      engine.world.gravity.y = 0; 

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff); // Белый фон, но canvas прозрачный в CSS
      
      // Добавляем освещение
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
      dirLight.position.set(10, 20, 10);
      scene.add(dirLight);

      // Свет от мыши
      mouseLight = new THREE.PointLight(0x42A5F5, 1.5, 600);
      mouseLight.position.set(0, 0, 100);
      scene.add(mouseLight);

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
      camera.position.z = 400;

      renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      resize();

      createWalls();
      createParticles();

      document.addEventListener('mousemove', onMouseMove, false);
      document.addEventListener('mouseleave', () => { 
          mouse.set(-9999, -9999); 
          if(mouseLight) mouseLight.intensity = 0; // Выключаем свет, если мышь ушла
      });
      window.addEventListener('resize', resize, false);

      animate();
  }

  function createWalls() {
      if (walls.length > 0) World.remove(world, walls);
      
      const vFOV = THREE.MathUtils.degToRad(camera.fov);
      const height = 2 * Math.tan(vFOV / 2) * camera.position.z;
      const width = height * camera.aspect;
      const wallThickness = 100;

      walls = [
          Bodies.rectangle(0, -height/2 - wallThickness/2, width + wallThickness*2, wallThickness, { isStatic: true, restitution: 0.8 }), 
          Bodies.rectangle(0, height/2 + wallThickness/2, width + wallThickness*2, wallThickness, { isStatic: true, restitution: 0.8 }), 
          Bodies.rectangle(width/2 + wallThickness/2, 0, wallThickness, height + wallThickness*2, { isStatic: true, restitution: 0.8 }), 
          Bodies.rectangle(-width/2 - wallThickness/2, 0, wallThickness, height + wallThickness*2, { isStatic: true, restitution: 0.8 }) 
      ];
      World.add(world, walls);
  }

  function createParticles() {
      const geometry = RoundedRectGeometry(1, 0.6, 0.25); 
      const material = new THREE.MeshBasicMaterial({ color: PARTICLE_COLOR, transparent: true, opacity: 0.9, side: THREE.DoubleSide });
      
      const spawnRange = window.innerWidth / 3;

      particles.forEach(p => {
          scene.remove(p.mesh);
          World.remove(world, p.body);
      });
      particles = [];


      for (let i = 0; i < PARTICLE_COUNT; i++) {
          const mesh = new THREE.Mesh(geometry, material.clone());
          const baseScale = PARTICLE_BASE_SIZE * (0.8 + Math.random() * 0.4);
          mesh.scale.set(baseScale, baseScale, baseScale);
          scene.add(mesh);

          const startX = (Math.random() - 0.5) * spawnRange;
          const startY = (Math.random() - 0.5) * spawnRange;

          const body = Bodies.circle(startX, startY, PHYSICS_RADIUS * baseScale, {
              friction: 0,
              frictionAir: 0.05, 
              restitution: 0.5 
          });
          
          Body.setAngle(body, Math.random() * Math.PI * 2);
          Body.setVelocity(body, { x: (Math.random()-0.5)*2, y: (Math.random()-0.5)*2 });
          
          World.add(world, body);

          particles.push({ mesh, body, baseScale });
      }
  }

  function onMouseMove(event) {
      const vec = new THREE.Vector3(
          (event.clientX / window.innerWidth) * 2 - 1,
          -(event.clientY / window.innerHeight) * 2 + 1,
          0.5
      );
      vec.unproject(camera);
      vec.sub(camera.position).normalize();
      const distance = -camera.position.z / vec.z;
      const pos = camera.position.clone().add(vec.multiplyScalar(distance));
      mouse.set(pos.x, pos.y);
  }

  function resize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      createWalls();
  }

  function animate() {
      requestAnimationFrame(animate);

      Engine.update(engine, 1000 / 60);

      const now = Date.now();
      const pulseFactor = 1 + Math.sin(now * PULSE_SPEED) * PULSE_AMPLITUDE;

      // Обновляем позицию света мыши
      if (mouse.x > -9000) {
          mouseLight.position.x += (mouse.x - mouseLight.position.x) * 0.1;
          mouseLight.position.y += (mouse.y - mouseLight.position.y) * 0.1;
          mouseLight.intensity = 1.5;
      }

      particles.forEach(p => {
          const dx = mouse.x - p.body.position.x;
          const dy = mouse.y - p.body.position.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (mouse.x > -9000 && dist < ATTRACTION_RADIUS && dist > 1) {
              const normalX = dx / dist;
              const normalY = dy / dist;

              const deltaFromOrbit = dist - ORBIT_RADIUS;

              const forceMagnitude = deltaFromOrbit * FORCE_STRENGTH * p.body.mass;

              Body.applyForce(p.body, p.body.position, {
                  x: normalX * forceMagnitude,
                  y: normalY * forceMagnitude
              });
          }

          p.mesh.position.x = p.body.position.x;
          p.mesh.position.y = p.body.position.y;
          
          if (!p.mesh.position.z) p.mesh.position.z = (Math.random() - 0.5) * 50;
          
          p.mesh.rotation.z = p.body.angle;

          const currentScale = p.baseScale * pulseFactor;
          p.mesh.scale.set(currentScale, currentScale, currentScale);
      });

      renderer.render(scene, camera);
  }

  document.addEventListener('DOMContentLoaded', () => {
      init();
  });

</script>