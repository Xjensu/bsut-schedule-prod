<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

<style>
/* Reset & Basic Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: "SF Pro Text", "Myriad Set Pro", "SF Pro Icons", "Helvetica Neue", "Helvetica", "Arial", sans-serif;
    background-color: #ffffff;
    color: #1d1d1f;
    overflow-x: hidden;
}

#webgl-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
}

/* Content Placeholder */
.main-content-wrapper {
    padding-top: 40px;
    padding-bottom: 40px;
    padding-left: 20px;
    padding-right: 20px;
    min-height: 100vh;
}

/* Schedule Styles */
.schedule-wrapper {
    max-width: 1000px;
    margin: 0 auto;
}

.page-header {
    text-align: center;
    margin-bottom: 60px;
}

.page-header h1 {
    font-size: 48px;
    font-weight: 700;
    letter-spacing: -0.005em;
    margin-bottom: 10px;
    color: #1d1d1f;
}

.page-header .subtitle {
    font-size: 24px;
    color: #86868b;
    font-weight: 400;
}

.departments-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
    margin-bottom: 60px;
}

.department-card {
    background: #fff;
    border-radius: 18px;
    padding: 30px;
    text-decoration: none;
    color: #1d1d1f;
    box-shadow: 0 4px 6px rgba(0,0,0,0.02), 0 12px 24px rgba(0,0,0,0.04);
    transition: all 0.3s cubic-bezier(0,0,0.5,1);
    display: flex;
    justify-content: space-between;
    align-items: center;
    border: 1px solid rgba(0,0,0,0.05);
}

.department-card:hover {
    transform: scale(1.02);
    box-shadow: 0 8px 15px rgba(0,0,0,0.05), 0 20px 40px rgba(0,0,0,0.1);
}

.department-card h2 {
    font-size: 21px;
    font-weight: 600;
    line-height: 1.2;
    margin-right: 15px;
}

.department-card .arrow {
    font-size: 24px;
    color: #0066cc;
    opacity: 0;
    transform: translateX(-10px);
    transition: all 0.3s ease;
}

.department-card:hover .arrow {
    opacity: 1;
    transform: translateX(0);
}
</style>

<canvas id="webgl-canvas"></canvas>

<div class="main-content-wrapper">
    <div class="schedule-wrapper">
        <header class="page-header">
            <h1>Расписание Занятий</h1>
        </header>

        <div class="departments-grid">
            <% if @faculties.present? %>
                <% @faculties.each do |faculty| %>
                    <a href="<%= faculty_path(faculty.id) %>" class="department-card" data-turbo="false">
                        <h2><%= faculty.full_name %></h2>
                        <span class="arrow">→</span>
                    </a>
                <% end %>
            <% else %>
                <p style="text-align: center; color: #86868b;">Нет данных о факультетах</p>
            <% end %>
        </div>
    </div>
</div>

<script>
(function() {
    function RoundedRectGeometry(width, height, radius) {
        const shape = new THREE.Shape();
        const x = -width / 2, y = -height / 2;
        shape.moveTo(x, y + radius);
        shape.lineTo(x, y + height - radius);
        shape.quadraticCurveTo(x, y + height, x + radius, y + height);
        shape.lineTo(x + width - radius, y + height);
        shape.quadraticCurveTo(x + width, y, x + width, y + height - radius);
        shape.lineTo(x + width, y + radius);
        shape.quadraticCurveTo(x + width, y, x + width - radius, y);
        shape.lineTo(x + radius, y);
        shape.quadraticCurveTo(x, y, x, y + radius);
        return new THREE.ShapeGeometry(shape);
    }

    const Engine = Matter.Engine,
        World = Matter.World,
        Bodies = Matter.Bodies,
        Body = Matter.Body;

    let camera, scene, renderer;
    let particles = []; 

    let engine, world;
    let walls = [];

    const PARTICLE_COUNT = 200; 
    const PARTICLE_BASE_SIZE = 4;
    const PHYSICS_RADIUS_MULTIPLIER = 0.5; 
    const PHYSICS_RADIUS = PARTICLE_BASE_SIZE * PHYSICS_RADIUS_MULTIPLIER; 

    const PARTICLE_COLOR = 0x42A5F5; 

    const ATTRACTION_RADIUS = 350; 
    const ORBIT_RADIUS = 120; 
    const FORCE_STRENGTH = 0.00005; 

    const PULSE_SPEED = 0.003;
    const PULSE_AMPLITUDE = 0.2; 

    let mouse = new THREE.Vector2(-9999, -9999);
    let mouseLight; 

    function init() {
        const canvas = document.getElementById('webgl-canvas');
        if (!canvas) return;

        // Clean up previous instance if any
        if (renderer) {
            renderer.dispose();
        }
        if (engine) {
            Matter.Engine.clear(engine);
        }

        engine = Engine.create();
        world = engine.world;
        engine.world.gravity.y = 0; 

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff); 
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        mouseLight = new THREE.PointLight(0x42A5F5, 1.5, 600);
        mouseLight.position.set(0, 0, 100);
        scene.add(mouseLight);

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.z = 400;

        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        resize();

        createWalls();
        createParticles();

        document.addEventListener('mousemove', onMouseMove, false);
        document.addEventListener('mouseleave', () => { 
            mouse.set(-9999, -9999); 
            if(mouseLight) mouseLight.intensity = 0; 
        });
        window.addEventListener('resize', resize, false);

        animate();
    }

    function createWalls() {
        if (walls.length > 0) World.remove(world, walls);
        
        const vFOV = THREE.MathUtils.degToRad(camera.fov);
        const height = 2 * Math.tan(vFOV / 2) * camera.position.z;
        const width = height * camera.aspect;
        const wallThickness = 100;

        walls = [
            Bodies.rectangle(0, -height/2 - wallThickness/2, width + wallThickness*2, wallThickness, { isStatic: true, restitution: 0.8 }), 
            Bodies.rectangle(0, height/2 + wallThickness/2, width + wallThickness*2, wallThickness, { isStatic: true, restitution: 0.8 }), 
            Bodies.rectangle(width/2 + wallThickness/2, 0, wallThickness, height + wallThickness*2, { isStatic: true, restitution: 0.8 }), 
            Bodies.rectangle(-width/2 - wallThickness/2, 0, wallThickness, height + wallThickness*2, { isStatic: true, restitution: 0.8 }) 
        ];
        World.add(world, walls);
    }

    function createParticles() {
        const geometry = RoundedRectGeometry(1, 0.6, 0.25); 
        const material = new THREE.MeshBasicMaterial({ color: PARTICLE_COLOR, transparent: true, opacity: 0.9, side: THREE.DoubleSide });
        
        const spawnRange = window.innerWidth / 3;

        particles.forEach(p => {
            scene.remove(p.mesh);
            World.remove(world, p.body);
        });
        particles = [];


        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const mesh = new THREE.Mesh(geometry, material.clone());
            const baseScale = PARTICLE_BASE_SIZE * (0.8 + Math.random() * 0.4);
            mesh.scale.set(baseScale, baseScale, baseScale);
            scene.add(mesh);

            const startX = (Math.random() - 0.5) * spawnRange;
            const startY = (Math.random() - 0.5) * spawnRange;

            const body = Bodies.circle(startX, startY, PHYSICS_RADIUS * baseScale, {
                friction: 0,
                frictionAir: 0.05, 
                restitution: 0.5 
            });
            
            Body.setAngle(body, Math.random() * Math.PI * 2);
            Body.setVelocity(body, { x: (Math.random()-0.5)*2, y: (Math.random()-0.5)*2 });
            
            World.add(world, body);

            particles.push({ mesh, body, baseScale });
        }
    }

    function onMouseMove(event) {
        const vec = new THREE.Vector3(
            (event.clientX / window.innerWidth) * 2 - 1,
            -(event.clientY / window.innerHeight) * 2 + 1,
            0.5
        );
        vec.unproject(camera);
        vec.sub(camera.position).normalize();
        const distance = -camera.position.z / vec.z;
        const pos = camera.position.clone().add(vec.multiplyScalar(distance));
        mouse.set(pos.x, pos.y);
    }

    function resize() {
        if (!camera || !renderer) return;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        createWalls();
    }

    function animate() {
        requestAnimationFrame(animate);

        if (!engine || !scene || !camera || !renderer) return;

        Engine.update(engine, 1000 / 60);

        const now = Date.now();
        const pulseFactor = 1 + Math.sin(now * PULSE_SPEED) * PULSE_AMPLITUDE;

        if (mouse.x > -9000) {
            mouseLight.position.x += (mouse.x - mouseLight.position.x) * 0.1;
            mouseLight.position.y += (mouse.y - mouseLight.position.y) * 0.1;
            mouseLight.intensity = 1.5;
        }

        particles.forEach(p => {
            const dx = mouse.x - p.body.position.x;
            const dy = mouse.y - p.body.position.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (mouse.x > -9000 && dist < ATTRACTION_RADIUS && dist > 1) {
                const normalX = dx / dist;
                const normalY = dy / dist;

                const deltaFromOrbit = dist - ORBIT_RADIUS;

                const forceMagnitude = deltaFromOrbit * FORCE_STRENGTH * p.body.mass;

                Body.applyForce(p.body, p.body.position, {
                    x: normalX * forceMagnitude,
                    y: normalY * forceMagnitude
                });
            }

            p.mesh.position.x = p.body.position.x;
            p.mesh.position.y = p.body.position.y;
            
            if (!p.mesh.position.z) p.mesh.position.z = (Math.random() - 0.5) * 50;
            
            p.mesh.rotation.z = p.body.angle;

            const currentScale = p.baseScale * pulseFactor;
            p.mesh.scale.set(currentScale, currentScale, currentScale);
        });

        renderer.render(scene, camera);
    }

    document.addEventListener("turbo:load", init);
    if (document.readyState === "complete" || document.readyState === "interactive") {
        init();
    } else {
        document.addEventListener("DOMContentLoaded", init);
    }
})();
</script>